#from pandas import DataFrame
#import ast
#import json
#from sklearn.model_selection import GridSearchCV
#from sklearn.preprocessing import StandardScaler
#from sklearn.feature_extraction.text import TfidfTransformer
#from sklearn.feature_extraction.text import TfidfVectorizer
#from sklearn.decomposition import PCA
#from sklearn.decomposition import TruncatedSVD
#from sklearn.feature_selection import SelectKBest
#from sklearn.preprocessing import FunctionTransformer

import pandas as pd
import numpy as np

from sklearn.base import TransformerMixin
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.model_selection import RandomizedSearchCV
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.feature_selection import f_classif
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.calibration import CalibratedClassifierCV
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix
from sklearn.metrics import f1_score
from sklearn.metrics import roc_auc_score
from sklearn.metrics import recall_score
from sklearn.metrics import roc_curve
from sklearn.metrics import precision_score

from xgboost import XGBClassifier
from scipy.stats import uniform, truncnorm, randint

#https://zacstewart.com/2014/08/05/pipelines-of-featureunions-of-pipelines.html
class DenseTransformer(TransformerMixin):
    def fit(self, X, y=None, **fit_params):
        return self

    def transform(self, X, y=None, **fit_params):
        if('csr_matrix' in str(X.__class__)):
            print('SPARSE!')
            return X.toarray()
        else:
            return X

csv_train_path = '/media/cuckoohost/HD/OneDrive/AndreViana/Documents/0 USP/2023.1/TCC/Codigos/csvs/objdump/objdump_preprocessed.csv'
csv_test_path = '/media/cuckoohost/HD/OneDrive/AndreViana/Documents/0 USP/2023.1/TCC/Codigos/csvs/objdump/objdump_preprocessed_test.csv'

df_train = pd.read_csv(csv_train_path)
df_test = pd.read_csv(csv_test_path)

df_train = df_train.dropna()
df_test = df_test.dropna()

y_train = df_train['isMalware']
X_train = df_train.drop(['isMalware', 'info'], axis=1)

y_test = df_test['isMalware']
X_test = df_test.drop(['isMalware', 'info'], axis=1)

text_column = 'opcodes_objdump_ordered'

column_transf = ColumnTransformer([
    ('txt_kw', CountVectorizer(ngram_range=(2,2), analyzer='word', lowercase=False), text_column)
])

pipeline_dt=Pipeline([('col_trans', column_transf),
                     ('dt_classifier',DecisionTreeClassifier(random_state=0))])

pipeline_rf=Pipeline([('col_trans', column_transf),
                     ('rf_classifier',RandomForestClassifier(random_state=0))])

pipeline_svm=Pipeline([('col_trans', column_transf),
                     ('svm_classifier',SVC(random_state=0))])

pipeline_knn=Pipeline([('col_trans', column_transf),
                     ('to_dense', DenseTransformer()),
                     ('knn_classifier',KNeighborsClassifier())])

pipeline_xgboost=Pipeline([('col_trans', column_transf),
                     ('xgboost_classifier',XGBClassifier(random_state=0, tree_method='gpu_hist'))])

model_params_dt = {
    'col_trans__txt_kw__max_df': truncnorm(a=0.5, b=1, loc=0.75, scale=0.1),
    'col_trans__txt_kw__min_df': truncnorm(a=0, b=0.49, loc=0.25, scale=0.1),
    'dt_classifier__criterion' : ['gini', 'entropy', 'log_loss'],
    'dt_classifier__splitter' : ['best', 'random'],
    'dt_classifier__min_samples_leaf': randint(1,5),
    'dt_classifier__min_samples_split' : randint(2,5)
}

randsearch_dt = RandomizedSearchCV(pipeline_dt, model_params_dt, n_jobs=8, n_iter=100, cv=3, random_state=0)

calibrator = CalibratedClassifierCV(randsearch_dt, cv=3)
calibrator.fit(X_train, y_train)

preds = calibrator.predict_proba(X_train)[:,1]

fpr, tpr, thresholds = roc_curve(y_train, preds)
optimal_idx = np.argmax(tpr - fpr)
optimal_threshold = thresholds[optimal_idx]
print(optimal_threshold)
ydt_pred = (calibrator.predict_proba(X_test)[:,1] >= optimal_threshold).astype(bool)

model_params_rf = {
    'col_trans__txt_kw__max_df': truncnorm(a=0.5, b=1, loc=0.75, scale=0.1),
    'col_trans__txt_kw__min_df': truncnorm(a=0, b=0.49, loc=0.25, scale=0.1),
    'rf_classifier__n_estimators' : randint(50,300),
    'rf_classifier__criterion' : ['gini', 'entropy', 'log_loss'],
    'rf_classifier__min_samples_leaf': randint(1,5),
    'rf_classifier__min_samples_split' : randint(2,5)
}

randsearch_rf = RandomizedSearchCV(pipeline_rf, model_params_rf, n_jobs=8, n_iter=100, cv=3, random_state=0)

calibrator = CalibratedClassifierCV(randsearch_rf, cv=3)
calibrator.fit(X_train, y_train)

preds = calibrator.predict_proba(X_train)[:,1]

fpr, tpr, thresholds = roc_curve(y_train, preds)
optimal_idx = np.argmax(tpr - fpr)
optimal_threshold = thresholds[optimal_idx]
print(optimal_threshold)
yrf_pred = (calibrator.predict_proba(X_test)[:,1] >= optimal_threshold).astype(bool)

model_params_svm = {
    'col_trans__txt_kw__max_df': truncnorm(a=0.5, b=1, loc=0.75, scale=0.1),
    'col_trans__txt_kw__min_df': truncnorm(a=0, b=0.49, loc=0.25, scale=0.1),
    'svm_classifier__kernel' :['linear', 'poly', 'rbf', 'sigmoid'], 
    'svm_classifier__degree': randint(1,5)
}

randsearch_svm = RandomizedSearchCV(pipeline_svm, model_params_svm, n_jobs=8, n_iter=100, cv=3, random_state=0)

calibrator = CalibratedClassifierCV(randsearch_svm, cv=3)
calibrator.fit(X_train, y_train)

preds = calibrator.predict_proba(X_train)[:,1]

fpr, tpr, thresholds = roc_curve(y_train, preds)
optimal_idx = np.argmax(tpr - fpr)
optimal_threshold = thresholds[optimal_idx]
print(optimal_threshold)
ysvm_pred = (calibrator.predict_proba(X_test)[:,1] >= optimal_threshold).astype(bool)

model_params_knn = {
    'col_trans__txt_kw__max_df': truncnorm(a=0.5, b=1, loc=0.75, scale=0.1),
    'col_trans__txt_kw__min_df': truncnorm(a=0, b=0.49, loc=0.25, scale=0.1),
    'knn_classifier__weights' : ['uniform', 'distance'],
    'knn_classifier__n_neighbors' : randint(3,15),
    'knn_classifier__p': randint(1,4)
}

randsearch_knn = RandomizedSearchCV(pipeline_knn, model_params_knn, n_jobs=8, n_iter=100, cv=3, random_state=0)

calibrator = CalibratedClassifierCV(randsearch_knn, cv=3)
calibrator.fit(X_train, y_train)

preds = calibrator.predict_proba(X_train)[:,1]

fpr, tpr, thresholds = roc_curve(y_train, preds)
optimal_idx = np.argmax(tpr - fpr)
optimal_threshold = thresholds[optimal_idx]
print(optimal_threshold)
yknn_pred = (calibrator.predict_proba(X_test)[:,1] >= optimal_threshold).astype(bool)

model_params_xgboost = {
    'col_trans__txt_kw__max_df': truncnorm(a=0.5, b=1, loc=0.75, scale=0.1),
    'col_trans__txt_kw__min_df': truncnorm(a=0, b=0.49, loc=0.25, scale=0.1),
    'xgboost_classifier__sampling_method' : ['gradient_based', 'uniform'],
    'xgboost_classifier__max_depth': randint(2,10),
    'xgboost_classifier__n_estimators': randint(50,300),
    'xgboost_classifier__learning_rate' : uniform(0,1)
}

randsearch_xgboost = RandomizedSearchCV(pipeline_xgboost, model_params_xgboost, n_jobs=8, n_iter=100, cv=3, random_state=0)

calibrator = CalibratedClassifierCV(randsearch_xgboost, cv=3)
calibrator.fit(X_train, y_train)

preds = calibrator.predict_proba(X_train)[:,1]

fpr, tpr, thresholds = roc_curve(y_train, preds)
optimal_idx = np.argmax(tpr - fpr)
optimal_threshold = thresholds[optimal_idx]
print(optimal_threshold)
yxgboost_pred = (calibrator.predict_proba(X_test)[:,1] >= optimal_threshold).astype(bool)

print("### DecisionTree ###")
cm = confusion_matrix(y_test, ydt_pred)
print(cm)
print('acc: ', accuracy_score(y_test, ydt_pred))
print('pre: ', precision_score(y_test, ydt_pred))
print('rec: ', recall_score(y_test, ydt_pred))
print('f1s: ', f1_score(y_test, ydt_pred))
print('auc: ', roc_auc_score(y_test, ydt_pred))
print('\n')

print("### RandomForest ###")
cm = confusion_matrix(y_test, yrf_pred)
print(cm)
print('acc: ', accuracy_score(y_test, yrf_pred))
print('pre: ', precision_score(y_test, yrf_pred))
print('rec: ', recall_score(y_test, yrf_pred))
print('f1s: ', f1_score(y_test, yrf_pred))
print('auc: ', roc_auc_score(y_test, yrf_pred))
print('\n')

print("### XGBoost ###")
cm = confusion_matrix(y_test, yxgboost_pred)
print(cm)
print('acc: ', accuracy_score(y_test, yxgboost_pred))
print('pre: ', precision_score(y_test, yxgboost_pred))
print('rec: ', recall_score(y_test, yxgboost_pred))
print('f1s: ', f1_score(y_test, yxgboost_pred))
print('auc: ', roc_auc_score(y_test, yxgboost_pred))
print('\n')

print("### SVM ###")
cm = confusion_matrix(y_test, ysvm_pred)
print(cm)
print('acc: ', accuracy_score(y_test, ysvm_pred))
print('pre: ', precision_score(y_test, ysvm_pred))
print('rec: ', recall_score(y_test, ysvm_pred))
print('f1s: ', f1_score(y_test, ysvm_pred))
print('auc: ', roc_auc_score(y_test, ysvm_pred))
print('\n')

print("### KNN ###")
cm = confusion_matrix(y_test, yknn_pred)
print(cm)
print('acc: ', accuracy_score(y_test, yknn_pred))
print('pre: ', precision_score(y_test, yknn_pred))
print('rec: ', recall_score(y_test, yknn_pred))
print('f1s: ', f1_score(y_test, yknn_pred))
print('auc: ', roc_auc_score(y_test, yknn_pred))
print('\n')