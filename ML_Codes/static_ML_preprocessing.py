#from pandas import DataFrame
#import numpy as np
#import json
import pandas as pd
import ast

#retorna quantos headers tem que se encaixa nessa categorical_column
def healper_pr_categorical(array, categorical_column):
    contagem = 0
    headers = ast.literal_eval(array[1:-1])
    
    if isinstance(headers, tuple):
        for header in headers:
            valor = 'PR.' + header['type'] +'_'+ header['flags'] #esse aqui eh o valor da coluna
            if(valor == categorical_column):
                contagem +=1
    else:
        header = headers
        valor = 'PR.' + header['type'] +'_'+ header['flags'] #esse aqui eh o valor da coluna
        if(valor == categorical_column):
                contagem +=1
    
    return contagem

#retorna quantos headers tem que se encaixa nessa categorical_column
def healper_sh_categorical(array, categorical_column):
    if(len(array) <= 2):
        return 0

    contagem = 0
    headers = ast.literal_eval(array[1:-1])
    
    if isinstance(headers, tuple):
        for header in headers:
            valor = 'SH.' + header['type']#esse aqui eh o valor da coluna
            if(valor == categorical_column):
                contagem +=1
    else:
        header = headers
        valor = 'SH.' + header['type'] #esse aqui eh o valor da coluna
        if(valor == categorical_column):
                contagem +=1
    
    return contagem

#retorna a contagem desse type de relocation
def healper_rel_categorical(array, categorical_column):
    if(len(array) <= 2):
        return 0

    contagem = 0
    headers = ast.literal_eval(array[1:-1])
    
    if isinstance(headers, tuple):
        for header in headers:
            name = header['name']
            for entry in header['entries']:
                if(entry['type'] == categorical_column):
                    contagem+=1
    else:
        header = headers
        name = header['name']
        for entry in header['entries']:
                if(entry['type'] == categorical_column):
                    contagem+=1
    
    return contagem


#retorna quantos dynamic_tags tem type que se encaixa nessa categorical_column
def healper_dt_categorical(array, categorical_column):
    if(len(array) <= 2):
        return 0

    contagem = 0
    headers = ast.literal_eval(array[1:-1])
    
    if isinstance(headers, tuple):
        for header in headers:
            valor = header['type'] #esse aqui eh o valor da coluna
            if(valor == categorical_column):
                contagem +=1
    else:
        header = headers
        valor = header['type'] #esse aqui eh o valor da coluna
        if(valor == categorical_column):
                contagem +=1
    
    return contagem

#retorna quantos dynamic_tags tem bind.type que se encaixa nessa categorical_column
def healper_st_categorical(array, categorical_column):
    if(len(array) <= 2):
        return 0

    contagem = 0
    headers = ast.literal_eval(array[1:-1])
    
    if isinstance(headers, tuple):
        for header in headers:
            valor = header['bind'] + '.' + header['type'] #esse aqui eh o valor da coluna
            if(valor == categorical_column):
                contagem +=1
    else:
        header = headers
        valor = header['bind'] + '.' + header['type'] #esse aqui eh o valor da coluna
        if(valor == categorical_column):
                contagem +=1
    
    return contagem

csv_train_path = '/media/cuckoohost/HD/OneDrive/AndreViana/Documents/0 USP/2023.1/TCC/Codigos/csvs/static/static{}.csv'
training_samples_df_list = []

for i in range(6):
		this_df = pd.read_csv(csv_train_path.format(i))
		training_samples_df_list.append(this_df)

#combinando em um DF
df_train = pd.concat(training_samples_df_list, ignore_index=True)

csv_test_path = '/media/cuckoohost/HD/OneDrive/AndreViana/Documents/0 USP/2023.1/TCC/Codigos/csvs/static/static{}_test.csv'
test_samples_df_list = []

for i in range(6):
        this_df = pd.read_csv(csv_test_path.format(i))
        test_samples_df_list.append(this_df)

#combinando em um DF
df_test = pd.concat(test_samples_df_list, ignore_index=True)

df_train['isMagicOK'] = [True if 'ELF' in str(x) else False for x in df_train['magic_number']]
df_test['isMagicOK'] = [True if 'ELF' in str(x) else False for x in df_test['magic_number']]

df_train['entry_point_address'] = [0 if str(x) == 'nan' else int(str(x), 16) for x in df_train['entry_point_address']]
df_test['entry_point_address'] = [0 if str(x) == 'nan' else int(str(x), 16) for x in df_test['entry_point_address']]

df_train['isLittleEndianess'] = [True if 'little endian' in str(x) else False for x in df_train['endianess']]
df_test['isLittleEndianess'] = [True if 'little endian' in str(x) else False for x in df_test['endianess']]

from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import make_column_transformer
ohe_type = OneHotEncoder(sparse_output=False).set_output(transform="pandas")

transformed_train = ohe_type.fit_transform(df_train[['type']])
transformed_test = ohe_type.transform(df_test[['type']])

columns = ['elftype.' + str(x) for x in ohe_type.categories_[0]]

df_train[columns] = transformed_train
df_test[columns] = transformed_test

categorical_columns = ['PR.GNU_STACK_RW', 'PR.NOTE_R', 'PR.GNU_RELRO_R', 'PR.GNU_STACK_RWE', 'PR.LOAD_RWE', 'PR.DYNAMIC_RW', 'PR.GNU_EH_FRAME_R', 'PR.GNU_RELRO_RW', 'PR.LOAD_RW']
for categorical_column in categorical_columns:
    df_train[categorical_column] = [0 if 'nan' in str(x) else healper_pr_categorical(x,categorical_column) for x in df_train['program_headers']]

for categorical_column in categorical_columns:
    df_test[categorical_column] = [0 if 'nan' in str(x) else healper_pr_categorical(x,categorical_column) for x in df_test['program_headers']]

categorical_columns = ['SH.NOTE', 'SH.FINI_ARRAY', 'SH.NOBITS', 'SH.PREINIT_ARRAY', 'SH.GNU_HASH', 
'SH.NULL', 'SH.RELA', 'SH.VERNEED', 'SH.SYMTAB', 'SH.PROGBITS', 'SH.INIT_ARRAY', 
'SH.GNU_LIBLIST', 'SH.HASH', 'SH.VERDEF', 'SH.DYNAMIC', 'SH.STRTAB', 'SH.VERSYM', 
'SH.DYNSYM', 'SH.ARM_EXIDX']
for categorical_column in categorical_columns:
    df_train[categorical_column] = [0 if 'nan' in str(x) else healper_sh_categorical(x,categorical_column) for x in df_train['section_headers']]

for categorical_column in categorical_columns:
    df_test[categorical_column] = [0 if 'nan' in str(x) else healper_sh_categorical(x,categorical_column) for x in df_test['section_headers']]

categorical_columns = {'R_X86_64_TPOFF64', 'R_X86_64_JUMP_SLOT', 'R_X86_64_64', 'R_X86_64_COPY', 'R_X86_64_RELATIVE', 'R_X86_64_IRELATIVE', 'R_X86_64_GLOB_DAT'}
for categorical_column in categorical_columns:
    df_train['rel.' + categorical_column] = [0 if 'nan' in str(x) else healper_rel_categorical(x,categorical_column) for x in df_train['relocations']]

for categorical_column in categorical_columns:
    df_test['rel.' + categorical_column] = [0 if 'nan' in str(x) else healper_rel_categorical(x,categorical_column) for x in df_test['relocations']]

df_train = df_train.copy()
df_test = df_test.copy()

categorical_columns = ['JMPREL', 'GNU_LIBLIST', 'SYMENT', 'RPATH', 'SONAME', 'NULL', 'SYMBOLIC', 
'GNU_CONFLICT', 'VERSYM', 'FLAGS', 'VERNEED', 'VERDEFNUM', 'HASH', 'GNU_CONFLICTSZ',
'FINI', 'GNU_LIBLISTSZ', 'PLTRELSZ', 'FLAGS_1', 'PLTGOT', 'GNU_HASH', 'FINI_ARRAYSZ', 
'STRTAB', 'INIT', 'RELAENT', 'SYMTAB', 'DEBUG', 'PLTREL', 'INIT_ARRAY', 'FINI_ARRAY',
'VERNEEDNUM', 'RUNPATH', 'RELA', 'RELASZ', 'INIT_ARRAYSZ', 'BIND_NOW', 'VERDEF', 'NEEDED',
'RELACOUNT', 'STRSZ']
for categorical_column in categorical_columns:
    df_train['dt.' + categorical_column] = [0 if 'nan' in str(x) else healper_dt_categorical(x,categorical_column) for x in df_train['dynamic_tags']]

for categorical_column in categorical_columns:
    df_test['dt.' + categorical_column] = [0 if 'nan' in str(x) else healper_dt_categorical(x,categorical_column) for x in df_test['dynamic_tags']]

categorical_columns = ['<unknown>.OBJECT', 'LOCAL.OBJECT', 'WEAK.NOTYPE', 'WEAK.OBJECT', 'GLOBAL.FUNC', 'LOCAL.FUNC', 'LOCAL.FILE', 
'WEAK.FUNC', 'LOCAL.TLS', 'LOCAL.SECTION', 'GLOBAL.NOTYPE', 'GLOBAL.TLS', 'LOCAL.NOTYPE', 'GLOBAL.OBJECT']
for categorical_column in categorical_columns:
    df_train['st.' + categorical_column] = [0 if 'nan' in str(x) else healper_st_categorical(x,categorical_column) for x in df_train['symbol_tables']]

for categorical_column in categorical_columns:
    df_test['st.' + categorical_column] = [0 if 'nan' in str(x) else healper_st_categorical(x,categorical_column) for x in df_test['symbol_tables']]

#drop de colunas nao necessarias
df_train.drop(['magic_number','flags','endianess', 'type', 'program_headers', 'section_headers', 'relocations', 'dynamic_tags', 'symbol_tables', 'strings'], axis=1, inplace=True)
df_test.drop(['magic_number','flags','endianess', 'type', 'program_headers', 'section_headers', 'relocations', 'dynamic_tags', 'symbol_tables', 'strings'], axis=1, inplace=True)

print(df_train.head())
print(df_train.info(memory_usage="deep"))

print(df_test.head())
print(df_test.info(memory_usage="deep"))

df_train.to_csv('/media/cuckoohost/HD/OneDrive/AndreViana/Documents/0 USP/2023.1/TCC/Codigos/csvs/static/static_preprocessed.csv', index=False)
df_test.to_csv('/media/cuckoohost/HD/OneDrive/AndreViana/Documents/0 USP/2023.1/TCC/Codigos/csvs/static/static_preprocessed_test.csv', index=False)